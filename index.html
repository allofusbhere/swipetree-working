<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>SwipeTree — Family Navigator</title>
  <style>
*{box-sizing:border-box;-webkit-tap-highlight-color: transparent;}
html,body{margin:0;padding:0;background:#000;color:#fff;height:100%;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
  -webkit-touch-callout:none; user-select:none; -webkit-user-select:none;}
img{-webkit-touch-callout:none}
#app{display:flex;flex-direction:column;height:100%;}
.topbar{display:flex;align-items:center;gap:.75rem;padding:.5rem .75rem;background:#111;border-bottom:1px solid #222;position:sticky;top:0;z-index:5}
.brand{font-weight:700;letter-spacing:.3px;font-size:1rem;opacity:.9}
.spacer{flex:1}
.btn{background:#1f1f1f;border:1px solid #333;color:#fff;padding:.45rem .8rem;border-radius:.75rem;cursor:pointer}
.btn.subtle{background:#0e0e0e}
.btn:active{transform:scale(.98)}
#stage{position:relative;flex:1;overflow:hidden;display:flex;align-items:center;justify-content:center;padding:1rem}
#anchorWrap{position:relative;display:flex;flex-direction:column;align-items:center;justify-content:center;gap:.5rem}
#anchorImg{max-width:min(75vw,560px);max-height:min(65vh,560px);object-fit:contain;border-radius:16px;box-shadow:0 10px 40px rgba(0,0,0,.6);border:1px solid #222}
.name{font-size:1.1rem;opacity:.95;min-height:1.3em}
#gridOverlay{position:absolute;inset:0;background:#000;display:flex;flex-direction:column;z-index:4;align-items:center}
#gridOverlay.hidden{display:none}
.gridHeader{padding:.5rem 1rem;border-bottom:1px solid #222;width:100%;max-width:980px}
.grid{display:grid;grid-template-columns:repeat(3,1fr);gap:.75rem;padding:1rem;width:100%;max-width:980px;overflow-y:auto;-webkit-overflow-scrolling:touch;justify-content:center}
.grid.parents{grid-template-columns:repeat(2, minmax(180px, 1fr)); justify-content:center}
.tile{display:flex;flex-direction:column;align-items:center;gap:.5rem;background:#0b0b0b;border:1px solid #222;border-radius:14px;padding:.65rem;cursor:pointer}
.tile:active{transform:scale(.98)}
.tile img{width:100%;height:26vh;object-fit:contain;background:#000;border-radius:10px}
.tile .label{font-size:.95rem;opacity:.95;min-height:1.2em}
.highlight{outline:3px solid #7aa8ff;outline-offset:2px}
.noselect{user-select:none;-webkit-user-select:none;-ms-user-select:none}
.editOverlay{position:fixed;inset:0;background:rgba(0,0,0,.55);display:flex;align-items:center;justify-content:center;z-index:10}
.editOverlay.hidden{display:none}
.editCard{background:#111;border:1px solid #333;border-radius:16px;padding:1rem;min-width:min(90vw,420px);box-shadow:0 10px 40px rgba(0,0,0,.6)}
.editRow{display:flex;flex-direction:column;gap:.35rem;margin-bottom:.75rem}
.editRow label{font-size:.9rem;opacity:.85}
.editRow input{background:#0a0a0a;border:1px solid #333;color:#fff;padding:.55rem .6rem;border-radius:.6rem}
.editActions{display:flex;justify-content:flex-end;gap:.5rem;margin-top:.5rem}
  </style>
</head>
<body>
  <div id="app">
    <div class="topbar">
      <div class="brand">SwipeTree</div>
      <div class="spacer"></div>
      <button id="backBtn" class="btn subtle">← Back</button>
    </div>
    
    <div id="stage">
      <div id="anchorWrap">
        <img id="anchorImg" alt="Family Member" class="noselect">
        <div id="anchorName" class="name"></div>
      </div>
      
      <div id="gridOverlay" class="hidden">
        <div class="gridHeader">
          <h2 id="gridTitle">Navigation</h2>
        </div>
        <div id="grid" class="grid"></div>
      </div>
    </div>
  </div>

  <div id="editOverlay" class="editOverlay hidden">
    <div class="editCard">
      <div class="editRow">
        <label>Name</label>
        <input id="editName" type="text" placeholder="Enter name">
      </div>
      <div class="editRow">
        <label>Date of Birth</label>
        <input id="editDob" type="text" placeholder="e.g., 1990-01-15">
      </div>
      <div class="editActions">
        <button id="editCancel" class="btn">Cancel</button>
        <button id="editSave" class="btn">Save</button>
      </div>
    </div>
  </div>

  <script>
// SwipeTree with Cross-Device Labels
(function(){
  'use strict';
  
  const params = new URLSearchParams(location.search);
  const DEFAULT_IMG_BASE = 'https://allofusbhere.github.io/family-tree-images/';
  const IMG_BASE = (params.get('imgbase') || DEFAULT_IMG_BASE).replace(/\/?$/, '/');
  const IMG_EXT = '.jpg';
  const PLACEHOLDER_NAME = 'placeholder.jpg';
  const PLACEHOLDER = IMG_BASE + PLACEHOLDER_NAME;
  const MAX_CANDIDATES = 9, SWIPE_THRESHOLD = 40, LONGPRESS_MS = 520;

  const state = { 
    anchorId: null, 
    historyStack: [], 
    gridOpen: false, 
    gridType: null, 
    touchStart: null, 
    longPressTimer: null,
    namesMap: {},
    labelCache: {}
  };

  const anchorImg = document.getElementById('anchorImg');
  const anchorWrap = document.getElementById('anchorWrap');
  const anchorName = document.getElementById('anchorName');
  const gridOverlay = document.getElementById('gridOverlay');
  const grid = document.getElementById('grid');
  const gridTitle = document.getElementById('gridTitle');
  const backBtn = document.getElementById('backBtn');
  const editOverlay = document.getElementById('editOverlay');
  const editName = document.getElementById('editName');
  const editDob = document.getElementById('editDob');
  const editCancel = document.getElementById('editCancel');
  const editSave = document.getElementById('editSave');

  function idToSrc(id){ return IMG_BASE + id + IMG_EXT; }
  function exists(src){ return new Promise(r=>{ const i=new Image(); i.onload=()=>r(true); i.onerror=()=>r(false); i.src=src+cacheBust(); }); }
  const cacheBust = ()=> `?v=${Date.now()%1e7}`;
  function setURLHash(id){ try{ history.replaceState(null,'',`#${encodeURIComponent(id)}`); }catch{} }

  // Cross-device label functions
  async function getLabel(id) {
    try {
      const bust = Date.now();
      const res = await fetch(`/.netlify/functions/labels?id=${encodeURIComponent(id)}&t=${bust}`, {
        method: 'GET',
        cache: 'no-store',
        headers: { 'Accept': 'application/json' }
      });
      if (!res.ok) throw new Error('GET labels failed');
      const data = await res.json();
      return data;
    } catch (e) {
      console.warn('Label fetch failed, using localStorage fallback:', e);
      // Fallback to localStorage
      try {
        const stored = localStorage.getItem(`swipetree.meta.${id}`);
        return stored ? JSON.parse(stored) : { id, name: '', dob: '' };
      } catch {
        return { id, name: '', dob: '' };
      }
    }
  }

  async function setLabel(id, name, dob) {
    try {
      const res = await fetch('/.netlify/functions/labels', {
        method: 'POST',
        cache: 'no-store',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ id, name, dob })
      });
      if (!res.ok) throw new Error('POST labels failed');
      return res.json();
    } catch (e) {
      console.warn('Label save failed, using localStorage fallback:', e);
      // Fallback to localStorage
      localStorage.setItem(`swipetree.meta.${id}`, JSON.stringify({ id, name, dob }));
      return { ok: true };
    }
  }

  function getSavedMeta(id){ 
    try{ 
      return JSON.parse(localStorage.getItem(`swipetree.meta.${id}`)||'null'); 
    } catch {
      return null;
    } 
  }
  
  function saveMeta(id, meta){ 
    localStorage.setItem(`swipetree.meta.${id}`, JSON.stringify(meta||{})); 
  }
  
  async function displayNameFor(id){ 
    if(state.namesMap[id]) return state.namesMap[id]; 
    if(state.labelCache[id]) return state.labelCache[id].name || '';
    
    try {
      const data = await getLabel(id);
      state.labelCache[id] = { name: data.name || '', dob: data.dob || '' };
      return data.name || '';
    } catch {
      const m = getSavedMeta(id); 
      return m && m.name ? m.name : ''; 
    }
  }

  async function tryLoadNamesMap(){
    try{
      const res = await fetch(IMG_BASE + 'names.json' + cacheBust());
      if(res.ok){ 
        const data = await res.json(); 
        if(data && typeof data==='object') state.namesMap=data; 
      }
    } catch {}
  }

  function getIdParts(idStr){ const p=idStr.split('.'); return { baseId:p[0], isSpouse:(p[1]==='1'), partnerHint:(p[2]||null) }; }
  function countTrailingZeros(s){ let c=0; for(let i=s.length-1;i>=0;i--){ if(s[i]!=='0') break; c++; } return c; }
  const toInt = s=>parseInt(s,10);
  function toStr(n,d){ let s=String(n); while(s.length<d) s='0'+s; return s; }

  function parentOf(idStr){
    const {baseId}=getIdParts(idStr); const d=baseId.length; const tz=countTrailingZeros(baseId);
    if(tz<=0) return null; const n=toInt(baseId); const step=Math.pow(10,tz); const parent=n-(n%(step*10)); return toStr(parent,d);
  }
  function childrenOf(idStr){
    const {baseId}=getIdParts(idStr); const d=baseId.length; const tz=countTrailingZeros(baseId);
    const childStep=Math.pow(10, Math.max(0,tz-1)); const floor=toInt(baseId) - (toInt(baseId) % (childStep*10));
    const out=[]; for(let k=1;k<=MAX_CANDIDATES;k++) out.push(toStr(floor+k*childStep,d)); return out;
  }
  function siblingsOf(idStr){
    const {baseId}=getIdParts(idStr); const d=baseId.length; const tz=countTrailingZeros(baseId);
    const sibStep=Math.pow(10,tz); const floor=toInt(baseId) - (toInt(baseId) % (sibStep*10));
    const out=[]; for(let k=1;k<=MAX_CANDIDATES;k++){ const s=toStr(floor+k*sibStep,d); if(s!==baseId) out.push(s); } return out;
  }

  async function setAnchor(idStr, pushHistory=true){
    if(state.gridOpen) closeGrid();
    if(state.anchorId && pushHistory) state.historyStack.push(state.anchorId);
    state.anchorId=idStr; setURLHash(idStr);
    const src=idToSrc(idStr); const ok=await exists(src);
    anchorImg.src = ok ? (src+cacheBust()) : (PLACEHOLDER+cacheBust());
    anchorImg.classList.remove('highlight');
    
    const name = await displayNameFor(idStr);
    anchorName.textContent = name || '';
    
    requestAnimationFrame(()=>{ anchorImg.classList.add('highlight'); setTimeout(()=>anchorImg.classList.remove('highlight'),350); });
  }

  function openGrid(title,cards,kind=null){
    gridTitle.textContent=title; grid.innerHTML=''; grid.classList.remove('parents'); if(kind==='parents') grid.classList.add('parents');
    cards.forEach(c=>{
      const tile=document.createElement('div'); tile.className='tile noselect'; tile.dataset.id=c.id;
      tile.innerHTML=`<img alt="${c.id}" src="${c.src}${cacheBust()}"><div class="label">${c.name||''}</div>`;
      tile.addEventListener('click', async ()=>{ closeGrid(); await setAnchor(c.id); });
      grid.appendChild(tile);
    });
    gridOverlay.classList.remove('hidden'); state.gridOpen=true;
  }
  function closeGrid(){ gridOverlay.classList.add('hidden'); state.gridOpen=false; state.gridType=null; }

  function onTouchStart(e){ 
    if(state.longPressTimer) clearTimeout(state.longPressTimer);
    const t=e.touches?e.touches[0]:e; state.touchStart={x:t.clientX,y:t.clientY,time:Date.now()};
    state.longPressTimer=setTimeout(()=>{ openEdit(); }, LONGPRESS_MS);
  }
  function onTouchMove(e){ 
    if(!state.touchStart) return; 
    const t=e.touches?e.touches[0]:e;
    if(Math.abs(t.clientX-state.touchStart.x)>10||Math.abs(t.clientY-state.touchStart.y)>10) clearTimeout(state.longPressTimer);
  }
  function onTouchEnd(e){ 
    if(state.longPressTimer) clearTimeout(state.longPressTimer); 
    if(!state.touchStart) return;
    const t=e.changedTouches?e.changedTouches[0]:e; 
    const dx=t.clientX-state.touchStart.x, dy=t.clientY-state.touchStart.y;
    const adx=Math.abs(dx), ady=Math.abs(dy); 
    state.touchStart=null; 
    if(adx<40 && ady<40) return;
    if(adx>ady){ if(dx>0) handleSpouseSwipe(); else handleSiblingsSwipe(); } else { if(dy>0) handleChildrenSwipe(); else handleParentsSwipe(); }
  }

  async function existingCards(ids){ 
    const checks=await Promise.all(ids.map(id=>exists(idToSrc(id))));
    const out=[]; 
    for(let i=0;i<ids.length;i++) {
      if(checks[i]) {
        const name = await displayNameFor(ids[i]);
        out.push({id:ids[i], src:idToSrc(ids[i]), name});
      }
    }
    return out; 
  }
  async function handleChildrenSwipe(){ openGrid('Children', await existingCards(childrenOf(state.anchorId)), 'children'); state.gridType='children'; }
  async function handleSiblingsSwipe(){ openGrid('Siblings', await existingCards(siblingsOf(state.anchorId)), 'siblings'); state.gridType='siblings'; }
  async function handleParentsSwipe(){ 
    const p=parentOf(state.anchorId); const cards=[];
    if(p){ 
      const ok=await exists(idToSrc(p)); 
      const name = await displayNameFor(p);
      cards.push({id:p, src: ok?idToSrc(p):PLACEHOLDER, name});
      const sp=p+'.1'; const ok2=await exists(idToSrc(sp)); 
      const spouseName = await displayNameFor(sp);
      cards.push(ok2?{id:sp, src:idToSrc(sp), name:spouseName}:{id:'Parent2', src:PLACEHOLDER, name:''}); 
    }
    openGrid('Parents', cards, 'parents'); state.gridType='parents'; 
  }
  async function handleSpouseSwipe(){ 
    const p=getIdParts(state.anchorId); 
    const t=p.isSpouse?p.baseId:p.baseId+'.1'; 
    if(await exists(idToSrc(t))) await setAnchor(t); 
  }

  // SoftEdit overlay
  async function openEdit(){ 
    const id=state.anchorId; 
    let meta;
    try {
      meta = await getLabel(id);
    } catch {
      meta = getSavedMeta(id) || {};
    }
    editName.value = meta.name || ''; 
    editDob.value = meta.dob || ''; 
    editOverlay.classList.remove('hidden'); 
    setTimeout(()=>editName.focus(),0); 
  }
  function closeEdit(){ editOverlay.classList.add('hidden'); }
  
  editCancel.addEventListener('click', closeEdit);
  editOverlay.addEventListener('click', (e)=>{ if(e.target===editOverlay) closeEdit(); });
  editSave.addEventListener('click', async ()=>{ 
    const id=state.anchorId; 
    const name=editName.value.trim(); 
    const dob=editDob.value.trim(); 
    
    try {
      await setLabel(id, name, dob);
    } catch {
      saveMeta(id, { name, dob });
    }
    
    state.labelCache[id] = { name, dob };
    anchorName.textContent=name||''; 
    closeEdit(); 
  });

  // Attach gestures to anchor
  ['touchstart','mousedown'].forEach(ev=>anchorWrap.addEventListener(ev,onTouchStart,{passive:true}));
  ['touchmove','mousemove'].forEach(ev=>anchorWrap.addEventListener(ev,onTouchMove,{passive:true}));
  ['touchend','mouseup','mouseleave'].forEach(ev=>anchorWrap.addEventListener(ev,onTouchEnd,{passive:true}));

  backBtn.addEventListener('click', async ()=>{ 
    if(state.gridOpen){ closeGrid(); return; } 
    const prev=state.historyStack.pop(); 
    if(prev) await setAnchor(prev,false); 
  });

  // Suppress OS context menu
  document.addEventListener('contextmenu', e=>e.preventDefault());
  document.addEventListener('gesturestart', e=>e.preventDefault());
  document.addEventListener('gesturechange', e=>e.preventDefault());
  document.addEventListener('gestureend', e=>e.preventDefault());
  document.addEventListener('touchmove', e=>{ if(state.gridOpen===false) e.preventDefault(); }, {passive:false});

  (async function boot(){ 
    await tryLoadNamesMap(); 
    let start=decodeURIComponent((location.hash||'').replace(/^#/,'')).trim(); 
    if(!start) start='100000'; 
    await setAnchor(start,false); 
  })();

})();
  </script>
</body>
</html>
